-> javascript中的内存泄漏概念 理解 和 解决方案
    - 概念
        1) 当我们的程序 或者 脚本 需要运行的情况下  那么系统会 分配给 程序 内存 
            - 当 我们的 程序 一直 在执行 就会一直消耗内存
            - 在运行程序的 时候 我们必须将之前 不再使用的 内存 进行释放  如果没有进行释放 那么就产生内存泄漏的问题啦
            - 如果 没有进行 及时的 内存释放 那么将会导致 导致运行设备的性能消耗 可能导致程序的崩溃  后果非常严重
            - 总结：
                    没有进行将不再使用的内存释放 那么就是内存泄漏
    - 语言的 垃圾 回收机制
        1) 在大部分个语言 含有回收机制 （例如在C语言中 就 没有函数 垃圾回收机制 需要 程序员进行手动的进行释放）
            - 什么时候会进行 回收 内存呢 
            - 在 数据 和 对象 没有对象它进行引用 那么保存该数据的内存 就会被回收啦
            - 但是有怎么一种 这样的 情况 那么就是自己 调用自己 那么这个数据 一直被引用 那么就不会被回收 那么就产生内存泄漏啦
                - 我们进行举例
                    var arr = [ 1,2,3,4,5,6 ];
                这个数据是个 引用类型的数据 arr变量指向 这个数据 那么它的引用次数 就是1 那么就不会被 回收机制进行回收啦  这个就是 为什么 全局变量不会被回收啦 只能在页面关闭回收啦
                - 解决 那么就是在代码 后面 让 arr 指向一个 null
                    arr = null;
                    那么这样 [ 1,2,3,4,5,6 ] 就会被回收机制进行回收啦  内存就会进行释放啦
        2) 如果 知道 自己 编辑的代码 含有内存泄漏的问题呢
            - 方法：
                    就是在 连续 5次的垃圾回收 但是 占用的 内存一次比一次 大 
                    那么就是产生 内存 泄漏 啦 就需要进检查代码啦
        3) 然后 检测 内存的消耗呢 使用chrome-performance
            - 使用介绍
                - 进入 该 面板后 点击 小圆点( 模拟用户加载按钮 ) 看它 加载完毕 会出现一个消耗内存图
                - 进行观察内存的消耗
                - 自然观察到 水平状态的 消耗图 那么没有发生 内存泄漏的情况
                - 但是 如果 消耗图 成 '上山' 的状态图 那么 发生了 内存泄漏啦
        4) 使用 node 进行查看页面 进程内存的消耗
            - 使用 process.memotyUsage(); --- 需要在 node 中进行执行的
            - 返回值为一个对象  我们 查看 对象中的 headUsage 成员的值
                {
                    rss: 4935680,
                    heapTotal: 1826816,
                    heapUsed: 650472,
                    external: 49879
                }
            -   
                rss（resident set size）：所有内存占用，包括指令区和堆栈。
                heapTotal："堆"占用的内存，包括用到的和没用到的。
                heapUsed：用到的堆的部分。
                external： V8 引擎内部的 C++ 对象占用的内存。

    - 解决方案
        1) es6 中提供的 内存泄漏的 解决方案
            - 1. WebkMap
                1) 进行设置 内存的 回收时机（ 看完 博客后 感觉理解 还是含有一些模糊 下面的理解可能存在 误解 ）
                    、、、
                        const wm = new WebkMap();
                        let div = document.getElement( 'dv' );
                        wm.set( div , 'some information' );
                        wm.get( div );
                    、、、javascript
                2) 我先按照 自己的理解 介绍 WebkMap
                    - 我们在全局中 设置 一个变量 并且 让其 指向一个 DOM对象 那么该变量肯定在 页面关闭之后才会回收吧
                    - 先使用 WebkMap 进行设置 后 那么在这个 变量 没有被引用 那么就会 被回收啦（就是说 在检测页面中没有对象 进行引用 那么全局变量也是被回收的  那么这样就打破啦 全局变量不能被回收的概念啦）
                    - WebkMap 是设置 数据的 弱类型的回收 （弱类型的意思就是 在DOM元素 在没有引用的情况下 不是说 除自身变量的指向之外）
                3) 那么这个 检测是否 成功进行（以上是否生效呢）是否呢
                    - 博客上的 代码 目前还是看不太 懂  
                    - 首先执行 一个命令 获取 手动的释放内存的权限
                    - node --expose-gc 将数据 获取到
                    - 进入 node 执行以下的代码
                        、、、
                            / 手动执行一次垃圾回收，保证获取的内存使用状态准确
                            > global.gc(); 
                            undefined

                            // 查看内存占用的初始状态，heapUsed 为 4M 左右
                            > process.memoryUsage(); 
                            { rss: 21106688,
                            heapTotal: 7376896,
                            heapUsed: 4153936,
                            external: 9059 }

                            > let wm = new WeakMap();
                            undefined

                            > let b = new Object();
                            undefined

                            > global.gc();
                            undefined

                            // 此时，heapUsed 仍然为 4M 左右
                            > process.memoryUsage(); 
                            { rss: 20537344,
                            heapTotal: 9474048,
                            heapUsed: 3967272,
                            external: 8993 }

                            // 在 WeakMap 中添加一个键值对， 
                            // 我们看 这里 进行处理啦 下面看 headUsage是否 方式变化呢
                            // 键名为对象 b，键值为一个 5*1024*1024 的数组  
                            > wm.set(b, new Array(5*1024*1024));
                            WeakMap {}

                            // 手动执行一次垃圾回收
                            > global.gc();
                            undefined

                            // 此时，heapUsed 为 45M 左右
                            > process.memoryUsage(); 
                            { rss: 62652416,
                            heapTotal: 51437568,
                            heapUsed: 45911664,
                            external: 8951 }

                            // 解除对象 b 的引用  
                            > b = null;
                            null

                            // 再次执行垃圾回收
                            // 我们 进行手动的释放 内存 那么我们发现 内存 进行回收啦
                            > global.gc();
                            undefined

                            // 解除 b 的引用以后，heapUsed 变回 4M 左右
                            // 说明 WeakMap 中的那个长度为 5*1024*1024 的数组被销毁了
                            // 我们使用 WebkMap 之后 b 变量 执行的 数组 进行销毁啦  内存就回收完成
                            > process.memoryUsage(); 
                            { rss: 20639744,
                            heapTotal: 8425472,
                            heapUsed: 3979792,
                            external: 8956 }
                        、、、javascript
                    - 看到代码 
                        - 大概的理解 就是 我们使用 new WebkMap() 的set 方法让 变量 以键值对的方法存储
                        - 执行 WebkMap() 就可以完成 内存的释放啦